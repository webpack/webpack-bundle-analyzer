const childProcess = require("node:child_process");
const fs = require("node:fs");
const path = require("node:path");
const url = require("node:url");
const puppeteer = require("puppeteer");
const { isZstdSupported } = require("../src/sizeUtils");

let browser;

function generateReportFrom(statsFilename, additionalOptions = "") {
  childProcess.execSync(
    `../lib/bin/analyzer.js ${additionalOptions} -m static -r output/report.html -O stats/${statsFilename}`,
    {
      cwd: __dirname,
    },
  );
}

async function getTitleFromReport() {
  const page = await browser.newPage();
  await page.goto(
    url.pathToFileURL(path.resolve(__dirname, "./output/report.html")),
  );
  return await page.title();
}

function forEachChartItem(chartData, cb) {
  for (const item of chartData) {
    cb(item);

    if (item.groups) {
      forEachChartItem(item.groups, cb);
    }
  }
}

async function getChartData() {
  const page = await browser.newPage();
  await page.goto(
    url.pathToFileURL(path.resolve(__dirname, "./output/report.html")),
  );
  return await page.evaluate(() => globalThis.chartData);
}

async function getCompressionAlgorithm() {
  const page = await browser.newPage();
  await page.goto(
    url.pathToFileURL(path.resolve(__dirname, "./output/report.html")),
  );
  return await page.evaluate(() => globalThis.compressionAlgorithm);
}

async function expectValidReport(opts) {
  const { bundleLabel = "bundle.js", statSize = 141 } = opts || {};

  expect(fs.existsSync(path.resolve(__dirname, "./output/report.html"))).toBe(
    true,
  );
  const chartData = await getChartData();
  expect(chartData[0]).toMatchObject({
    label: bundleLabel,
    statSize,
  });
}

function generateJSONReportFrom(statsFilename) {
  childProcess.execSync(
    `../lib/bin/analyzer.js -m json -r output/report.json stats/${statsFilename}`,
    {
      cwd: __dirname,
    },
  );
}

describe("Analyzer", () => {
  beforeAll(async () => {
    browser = await puppeteer.launch();
    await fs.promises.rm(path.resolve(__dirname, "./output"), {
      force: true,
      recursive: true,
    });
  });

  afterEach(async () => {
    await fs.promises.rm(path.resolve(__dirname, "./output"), {
      force: true,
      recursive: true,
    });
  });

  afterAll(async () => {
    await browser.close();
  });

  it("should support stats files with all the information in `children` array", async () => {
    generateReportFrom("with-children-array.json");
    await expectValidReport();
  });

  it("should generate report containing worker bundles", async () => {
    generateReportFrom("with-worker-loader/stats.json");
    const chartData = await getChartData();
    expect(chartData[1]).toMatchObject({
      label: "bundle.worker.js",
    });
  });

  it("should generate report for array webpack.config.js", async () => {
    generateReportFrom("with-array-config/stats.json");
    const chartData = await getChartData();
    expect(chartData).toHaveLength(2);
    expect(chartData[0]).toMatchObject({
      label: "config-1-main.js",
    });
    expect(chartData[1]).toMatchObject({
      label: "config-2-main.js",
    });
  });

  it("should generate report when worker bundles have dynamic imports", async () => {
    generateReportFrom("with-worker-loader-dynamic-import/stats.json");
    const chartData = await getChartData();
    expect(chartData[1]).toMatchObject({
      label: "1.bundle.worker.js",
    });
  });

  it("should support stats files with modules inside `chunks` array", async () => {
    generateReportFrom("with-modules-in-chunks/stats.json");
    const chartData = await getChartData();
    expect(chartData).toMatchObject(
      require("./stats/with-modules-in-chunks/expected-chart-data"),
    );
  });

  it("should record accurate byte lengths for sources with special chars", async () => {
    generateReportFrom("with-special-chars/stats.json");
    const chartData = await getChartData();
    expect(chartData).toMatchObject(
      require("./stats/with-special-chars/expected-chart-data"),
    );
  });

  it("should support bundles with invalid dynamic require calls", async () => {
    generateReportFrom("with-invalid-dynamic-require.json");
    await expectValidReport({ statSize: 136 });
  });

  it("should use information about concatenated modules generated by webpack 4", async () => {
    generateReportFrom("with-module-concatenation-info/stats.json");
    const chartData = await getChartData();
    expect(chartData[0].groups[0]).toMatchObject(
      require("./stats/with-module-concatenation-info/expected-chart-data"),
    );
  });

  it("should handle stats with minimal configuration", async () => {
    generateReportFrom("minimal-stats/stats.json");
    const chartData = await getChartData();
    expect(chartData).toHaveLength(0);
  });

  // eslint-disable-next-line jest/no-disabled-tests
  it.skip("should not filter out modules that we couldn't find during parsing", async () => {
    generateReportFrom("with-missing-parsed-module/stats.json");
    const chartData = await getChartData();
    let unparsedModules = 0;
    forEachChartItem(chartData, (item) => {
      if (typeof item.parsedSize !== "number") {
        unparsedModules++;
      }
    });
    expect(unparsedModules).toBe(1);
  });

  // eslint-disable-next-line jest/no-disabled-tests
  it.skip("should gracefully parse invalid chunks", async () => {
    generateReportFrom("with-invalid-chunk/stats.json");
    const chartData = await getChartData();
    const invalidChunk = chartData.find((i) => i.label === "invalid-chunk.js");
    expect(invalidChunk.groups).toMatchObject([
      {
        id: 1,
        label: "invalid.js",
        path: "./invalid.js",
        statSize: 24,
      },
    ]);
    expect(invalidChunk.statSize).toBe(24);
    expect(invalidChunk.parsedSize).toBe(30);
  });

  // eslint-disable-next-line jest/no-disabled-tests
  it.skip("should gracefully process missing chunks", async () => {
    generateReportFrom("with-missing-chunk/stats.json");
    const chartData = await getChartData();
    const invalidChunk = chartData.find((i) => i.label === "invalid-chunk.js");
    expect(invalidChunk).toBeDefined();
    expect(invalidChunk.statSize).toBe(24);
    forEachChartItem([invalidChunk], (item) => {
      expect(typeof item.statSize).toBe("number");
      expect(item.parsedSize).toBeUndefined();
    });
    const validChunk = chartData.find((i) => i.label === "valid-chunk.js");
    forEachChartItem([validChunk], (item) => {
      expect(typeof item.statSize).toBe("number");
      expect(typeof item.parsedSize).toBe("number");
    });
  });

  // eslint-disable-next-line jest/no-disabled-tests
  it.skip("should gracefully process missing module chunks", async () => {
    generateReportFrom("with-missing-module-chunks/stats.json");
    const chartData = await getChartData();
    const invalidChunk = chartData.find((i) => i.label === "invalid-chunk.js");
    expect(invalidChunk).toBeDefined();
    expect(invalidChunk.statSize).toBe(568);
    forEachChartItem([invalidChunk], (item) => {
      expect(typeof item.statSize).toBe("number");
      expect(item.parsedSize).toBeUndefined();
    });
    const validChunk = chartData.find((i) => i.label === "valid-chunk.js");
    forEachChartItem([validChunk], (item) => {
      expect(typeof item.statSize).toBe("number");
      expect(typeof item.parsedSize).toBe("number");
    });
  });

  it("should support stats files with js modules chunk", async () => {
    generateReportFrom("with-modules-chunk.json");
    await expectValidReport({ bundleLabel: "bundle.mjs" });
  });

  it("should support stats files with cjs chunk", async () => {
    generateReportFrom("with-cjs-chunk.json");
    await expectValidReport({ bundleLabel: "bundle.cjs" });
  });

  it("should properly parse extremely optimized bundle from webpack 5", async () => {
    generateReportFrom("extremely-optimized-webpack-5-bundle/stats.json");
    const chartData = await getChartData();
    expect(chartData).toMatchObject(
      require("./stats/extremely-optimized-webpack-5-bundle/expected-chart-data"),
    );
  });

  it("should properly parse webpack 5 bundle with single entry", async () => {
    generateReportFrom("webpack-5-bundle-with-single-entry/stats.json");
    const chartData = await getChartData();
    expect(chartData).toMatchObject(
      require("./stats/webpack-5-bundle-with-single-entry/expected-chart-data"),
    );
  });

  it("should properly parse webpack 5 bundle with multiple entries", async () => {
    generateReportFrom("webpack-5-bundle-with-multiple-entries/stats.json");
    const chartData = await getChartData();
    expect(chartData).toMatchObject(
      require("./stats/webpack-5-bundle-with-multiple-entries/expected-chart-data"),
    );
  });

  it("should properly parse webpack 5 bundle with an entry module that is a concatenated module", async () => {
    generateReportFrom(
      "webpack-5-bundle-with-concatenated-entry-module/stats.json",
    );
    const chartData = await getChartData();
    expect(chartData).toMatchObject(
      require("./stats/webpack-5-bundle-with-concatenated-entry-module/expected-chart-data.json"),
    );
  });

  it("should support generating JSON output for the report", async () => {
    generateJSONReportFrom("with-modules-in-chunks/stats.json");

    const chartData = require(path.resolve(__dirname, "output/report.json"));

    expect(chartData).toMatchObject(
      require("./stats/with-modules-in-chunks/expected-chart-data"),
    );
  });

  it("should support stats files with non-asset asset", async () => {
    generateReportFrom("with-non-asset-asset/stats.json");
    await expectValidReport({ bundleLabel: "bundle.js" });
  });

  it("should map chunks correctly to entrypoints", async () => {
    generateReportFrom("with-multiple-entrypoints/stats.json");
    const chartData = await getChartData();
    expect(chartData).toMatchObject(
      require("./stats/with-multiple-entrypoints/expected-chart-data"),
    );
  });

  it("should return empty chartData if there are no entrypoints", async () => {
    generateReportFrom("with-no-entrypoints/stats.json");
    const chartData = await getChartData();
    expect(chartData).toHaveLength(0);
  });

  describe("options", () => {
    describe("title", () => {
      it("should take the --title option", async () => {
        const reportTitle = "A string report title";
        generateReportFrom(
          "with-modules-chunk.json",
          `--title "${reportTitle}"`,
        );

        const generatedReportTitle = await getTitleFromReport();

        expect(generatedReportTitle).toBe(reportTitle);
      });

      it("should take the -t option", async () => {
        const reportTitle = "A string report title";

        generateReportFrom("with-modules-chunk.json", `-t "${reportTitle}"`);

        const generatedReportTitle = await getTitleFromReport();

        expect(generatedReportTitle).toBe(reportTitle);
      });

      it("should use a suitable default title", async () => {
        generateReportFrom("with-modules-chunk.json");

        const generatedReportTitle = await getTitleFromReport();

        expect(generatedReportTitle).toMatch(
          /^webpack-bundle-analyzer \[.* at \d{2}:\d{2}\]/u,
        );
      });
    });

    describe("compression algorithm", () => {
      it("should accept --compression-algorithm brotli", async () => {
        generateReportFrom(
          "with-modules-chunk.json",
          "--compression-algorithm brotli",
        );
        expect(await getCompressionAlgorithm()).toBe("brotli");
      });

      it("should accept --compression-algorithm gzip", async () => {
        generateReportFrom(
          "with-modules-chunk.json",
          "--compression-algorithm gzip",
        );
        expect(await getCompressionAlgorithm()).toBe("gzip");
      });

      if (isZstdSupported) {
        it("should accept --compression-algorithm zstd", async () => {
          generateReportFrom(
            "with-modules-chunk.json",
            "--compression-algorithm zstd",
          );
          expect(await getCompressionAlgorithm()).toBe("zstd");
        });
      }

      it("should default to gzip", async () => {
        generateReportFrom("with-modules-chunk.json");
        expect(await getCompressionAlgorithm()).toBe("gzip");
      });
    });
  });
});
